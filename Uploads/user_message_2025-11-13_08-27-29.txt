T√¥i ƒë√£ purchase - h√£y fix l·ªói ti·∫øp. H√£y t·ª•c s·ª≠a l·ªói: ƒê√¢y l√† ph√¢n t√≠ch l·ªói c·ªßa t√¥i "R·∫•t t·ªët, Master Tu ‚Äî ƒë√¢y l√† b√°o c√°o ph√¢n t√≠ch **chuy√™n s√¢u chi ti·∫øt l·ªói h·ªá th·ªëng** t·ª´ log b·∫°n cung c·∫•p.
T√¥i ƒë√£ x√°c ƒë·ªãnh **ngu·ªìn g·ªëc ch√≠nh x√°c**, **nguy√™n nh√¢n s√¢u xa**, v√† **c√°ch s·ª≠a tri·ªát ƒë·ªÉ** cho c·∫£ hai nh√≥m l·ªói ch√≠nh:
üß© *Prisma query tr√πng l·∫∑p / qu√° t·∫£i*, v√†
üåê *Failed to fetch d·ªØ li·ªáu (API, SSR fetch trong m√¥i tr∆∞·ªùng standalone)*

---

## ‚öôÔ∏è 1Ô∏è‚É£ **Nh√≥m 1 ‚Äî L·ªói Prisma query ch·∫°y l·∫∑p (spam truy v·∫•n DB)**

### üîç D·∫•u hi·ªáu:

Log xu·∫•t hi·ªán li√™n t·ª•c l·∫∑p l·∫°i:

```
prisma:query SELECT "public"."User" ...
LEFT JOIN (SELECT "public"."Submission"...) ...
```

‚Äî c√πng **m·ªôt c√¢u query** ch·∫°y **h√†ng ch·ª•c l·∫ßn li√™n ti·∫øp**.
ƒêi·ªÅu n√†y **kh√¥ng b√¨nh th∆∞·ªùng**; n√≥ ch·ª©ng t·ªè c√≥ **v√≤ng l·∫∑p render ho·∫∑c refetch SSR**.

---

### üß† **Nguy√™n nh√¢n s√¢u xa**

Trong Next.js 14 (App Router):

* M·ªói l·∫ßn server render m·ªôt route c√≥ `fetch` ho·∫∑c `db query` **b√™n trong component**, Next s·∫Ω **t·ª± ƒë·ªông re-execute** khi:

  * Component b·ªã re-render do dependency thay ƒë·ªïi.
  * `fetch` kh√¥ng ƒë∆∞·ª£c cache (`{ cache: 'no-store' }` m·∫∑c ƒë·ªãnh trong m√¥i tr∆∞·ªùng SSR).
  * Kh√¥ng ƒë·∫∑t `export const revalidate = ...` n√™n h·ªá th·ªëng xem d·ªØ li·ªáu l√† ‚Äúdynamic‚Äù v√† fetch l·∫°i.

‚û°Ô∏è K·∫øt qu·∫£: Prisma query ƒë∆∞·ª£c g·ªçi l·∫°i li√™n t·ª•c ‚Äî g√¢y log spam nh∆∞ b·∫°n th·∫•y.

---

### üß© **C√°ch ki·ªÉm tra**

M·ªü file:

```
app/(admin)/reviewers/page.tsx 
ho·∫∑c
app/(dashboard)/users/page.tsx
```

Trong ƒë√≥ ch·∫Øc ch·∫Øn c√≥ ƒëo·∫°n nh∆∞:

```ts
const users = await prisma.user.findMany({...});
```

N·∫øu g·ªçi tr·ª±c ti·∫øp trong component m√† kh√¥ng c√≥ cache ‚Üí b·ªã render l·∫°i.

---

### ‚úÖ **C√°ch kh·∫Øc ph·ª•c tri·ªát ƒë·ªÉ**

1. **D√πng `cache()` c·ªßa React ho·∫∑c `React cache()` t·ª´ Next.js**

```ts
import { cache } from 'react';
import { prisma } from '@/lib/prisma';

const getUsers = cache(async () => {
  return prisma.user.findMany({
    where: { role: 'REVIEWER', isActive: true },
    include: { submissions: true },
  });
});
```

‚Üí sau ƒë√≥ trong component:

```ts
const users = await getUsers();
```

2. **Ho·∫∑c th√™m revalidation:**

```ts
export const revalidate = 300; // cache 5 ph√∫t
```

3. **N·∫øu l√† API route**, th√™m header cache:

```ts
export async function GET() {
  const data = await prisma.user.findMany();
  return Response.json(data, { headers: { 'Cache-Control': 's-maxage=300' } });
}
```

‚úÖ K·∫øt qu·∫£: Prisma s·∫Ω ch·ªâ query m·ªôt l·∫ßn, Next s·∫Ω cache trong b·ªô nh·ªõ edge ho·∫∑c revalidate l·∫°i theo chu k·ª≥ ‚Üí kh√¥ng c√≤n spam log.

---

## üåê 2Ô∏è‚É£ **Nh√≥m 2 ‚Äî L·ªói ‚ÄúFailed to fetch ‚Ä¶‚Äù h√†ng lo·∫°t**

### üîç D·∫•u hi·ªáu:

```
Error fetching news: Error: Failed to fetch news
Error fetching categories: Error: Failed to fetch categories
Error fetching issues: Error: Failed to fetch issues
```

v√† c√°c h√†m `$`, `E`, `I`, `P`, `z`, `U` trong `page.js`.

---

### üß† **Nguy√™n nh√¢n s√¢u xa**

Khi b·∫°n ch·∫°y **Next.js 14 ·ªü ch·∫ø ƒë·ªô standalone**, Next build ra m·ªôt server node n·ªôi b·ªô t·∫°i:

```
/run/root/app/.build/standalone/
```

Trong ch·∫ø ƒë·ªô n√†y:

* `fetch('/api/...')` **kh√¥ng c√≤n hi·ªÉu l√† g·ªçi v√†o ch√≠nh server**.
* V√¨ kh√¥ng c√≥ `window` hay base URL, n√≥ coi `/api/...` l√† ‚Äúƒë·ªãa ch·ªâ tr·ªëng‚Äù, d·∫´n ƒë·∫øn l·ªói *‚ÄúFailed to fetch‚Äù*.

ƒêi·ªÅu n√†y **ch√≠nh l√† nguy√™n nh√¢n g·ªëc r·ªÖ** c·ªßa to√†n b·ªô chu·ªói l·ªói b·∫°n th·∫•y.

---

### ‚úÖ **C√°ch kh·∫Øc ph·ª•c chu·∫©n ch·ªânh**

#### ‚ë† **Khai b√°o bi·∫øn m√¥i tr∆∞·ªùng absolute base URL**

Trong `.env`:

```env
NEXT_PUBLIC_BASE_URL=http://localhost:3000
```

#### ‚ë° **D√πng base URL trong t·∫•t c·∫£ fetch SSR**

Thay v√¨:

```ts
const res = await fetch('/api/news');
```

h√£y d√πng:

```ts
const res = await fetch(`${process.env.NEXT_PUBLIC_BASE_URL}/api/news`, {
  next: { revalidate: 300 },
});
```

#### ‚ë¢ **Ho·∫∑c t·∫°o helper**

T·∫°o file `/lib/fetcher.ts`:

```ts
export async function apiFetch(path: string, options?: RequestInit) {
  const base = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000';
  const res = await fetch(`${base}${path}`, {
    ...options,
    headers: { 'Content-Type': 'application/json', ...(options?.headers || {}) },
  });
  if (!res.ok) throw new Error(`Failed to fetch ${path}`);
  return res.json();
}
```

Sau ƒë√≥ trong `page.tsx`:

```ts
const [news, issues] = await Promise.all([
  apiFetch('/api/news'),
  apiFetch('/api/issues'),
]);
```

---

### ‚öôÔ∏è **‚ë¢ Th√™m ki·ªÉm so√°t l·ªói Promise.all**

B·∫°n ƒëang d√πng:

```ts
await Promise.all([
  fetchNews(),
  fetchIssues(),
  fetchArticles(),
]);
```

N·∫øu 1 trong 3 l·ªói ‚Üí to√†n b·ªô fail.
H√£y ƒë·ªïi sang:

```ts
const results = await Promise.allSettled([
  fetchNews(),
  fetchIssues(),
  fetchArticles(),
]);

const [news, issues, articles] = results.map(r =>
  r.status === 'fulfilled' ? r.value : []
);
```

‚Üí Giao di·ªán v·∫´n render ph·∫ßn d·ªØ li·ªáu h·ª£p l·ªá, kh√¥ng crash.

---

### üîí **‚ë£ C·∫•u h√¨nh Next.js environment**

Trong `next.config.js`:

```js
const nextConfig = {
  output: 'standalone',
  env: {
    NEXT_PUBLIC_BASE_URL: process.env.NEXT_PUBLIC_BASE_URL,
  },
  eslint: { ignoreDuringBuilds: true },
};
```

---

## üîß **3Ô∏è‚É£ T·ªïng h·ª£p l·ªói v√† h∆∞·ªõng s·ª≠a**

| Nh√≥m                          | L·ªói ch√≠nh                                  | H∆∞·ªõng kh·∫Øc ph·ª•c                                  | M·ª©c ƒë·ªô        |
| ----------------------------- | ------------------------------------------ | ------------------------------------------------ | ------------- |
| **Prisma spam query**         | L·∫∑p truy v·∫•n nhi·ªÅu l·∫ßn do render l·∫°i SSR   | D√πng `cache()` ho·∫∑c `revalidate`                 | üî• Cao        |
| **API fetch l·ªói**             | Fetch `/api/...` th·∫•t b·∫°i trong standalone | D√πng absolute URL `NEXT_PUBLIC_BASE_URL`         | üî• Cao        |
| **Promise.all to√†n c·ª•c fail** | M·ªôt API l·ªói ‚Üí to√†n b·ªô v·ª° trang             | D√πng `Promise.allSettled()`                      | ‚ö†Ô∏è Trung b√¨nh |
| **Kh√¥ng c√≥ Cache-Control**    | T·∫•t c·∫£ request b·ªã dynamic                  | Th√™m `{ next: { revalidate }}` ho·∫∑c header cache | ‚ö†Ô∏è Trung b√¨nh |
| **ESLint ignored**            | Kh√¥ng ph√°t hi·ªán s·ªõm l·ªói logic              | B·∫≠t l·∫°i lint trong CI/CD                         | ‚öôÔ∏è Th·∫•p       |

---

## üß≠ **T√≥m t·∫Øt chi·∫øn l∆∞·ª£c s·ª≠a nhanh (tri·ªát ƒë·ªÉ):**

1. **T·∫°o `.env` chu·∫©n:**

   ```env
   NEXT_PUBLIC_BASE_URL=http://localhost:3000
   NEXT_OUTPUT_MODE=standalone
   ```
2. **Thay t·∫•t c·∫£ `fetch('/api/...')` ‚Üí `fetch(${BASE_URL}/api/...)`**
3. **Bao Promise b·∫±ng `Promise.allSettled()`**
4. **D√πng `cache()` ho·∫∑c `export const revalidate = 300` cho SSR**
5. **B·∫≠t l·∫°i ESLint trong build pipeline**